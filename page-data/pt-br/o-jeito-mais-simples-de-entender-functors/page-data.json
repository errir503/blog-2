{"componentChunkName":"component---src-templates-blog-post-js","path":"/pt-br/o-jeito-mais-simples-de-entender-functors/","webpackCompilationHash":"43b12c4933495268691d","result":{"data":{"site":{"siteMetadata":{"title":"Diel Duarte blog","author":"Diel Duarte","siteUrl":"https://dielduarte.github.io","pt_br":{"rootPath":"/blog/pt-br","title":"Bem vindo ao meu blog!"},"en":{"rootPath":"/blog/","title":"Welcome to my blog!"}}},"markdownRemark":{"id":"e05d6808-0871-5b25-99e1-fd341e47abe2","excerpt":"Eu realmente gosto de linguagens funcionais, e eu tenho estudado algumas nos últimos anos como Elm e agora Reason apenas por diversão. Nunca fiz nada sério com…","html":"<p>Eu realmente gosto de linguagens funcionais, e eu tenho estudado algumas nos últimos anos como Elm e agora Reason apenas por diversão. Nunca fiz nada sério com essas linguagens como um App em produção em alguma empresa que trabalhei, mas eu gosto de trazer conceitos dessas linguagens para o Javascript. Meu problema é que de alguma forma eu sempre acabo frustrado quando estou estudando alguns dos conceitos de programação funcional,</p>\n<p>como functors.</p>\n<h2 class=\"subtitle--separator\">Mais oque realmente são functors?</h2>\n<p>O jeito mais fácil de entender functors na minha humilde opinião é o conceito: </p>\n<ul>\n<li>Functors são funçōes que retornam o valor passado de uma maneira que você consegue mapea-lo quantas vezes precisar até chegar no resultado desejado. Dessa forma, isso vai te ajudar a vizualizar melhor o fluxo de transformação do dado ao invéz de ficar criando várias variáveis na mémoria para salvar os estados intermediários da transformação que não são úteis no resultado final. Lembra do método <code class=\"language-text\">promise.then</code> que conseguimos encadear várias chamadas <code class=\"language-text\">.then</code> tratando cada passo na transformação dos dados.</li>\n</ul>\n<p><code class=\"language-text\">talk is cheap, show me the code.</code></p>\n<p>Considerando que temos uma função como essa:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertMoneyToNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">money</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> moneyWithoutMask <span class=\"token operator\">=</span> money<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\$/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">parseFloat</span><span class=\"token punctuation\">(</span>moneyWithoutMask<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Vamos criar um helper chamado functor, essa função aceita qualquer tipo de valor e retorna esse valor mapeável como arrays, então agora conseguimos encadear chamadas .map transformando qualquer valor no valor desejado.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">functor</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">anyValue</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">map</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">f</span> <span class=\"token operator\">=></span> <span class=\"token function\">functor</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>anyValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  value<span class=\"token punctuation\">:</span> anyValue\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>como podemos ver, a função functor recebe <code class=\"language-text\">qualquer valor</code> e retorna um objeto com:</p>\n<ul>\n<li>Um método chamado <code class=\"language-text\">map</code> que recebe a função e retorna um functor do valor que a função passada retornou, fazendo com que o valor retornado seja mapeável novamente.</li>\n<li>Um campo chamado <code class=\"language-text\">value</code> que contém o resultado da ultima função executada, pesquisando você vai achar variações dessa ideia como o método <code class=\"language-text\">flatMap</code> que retorna o valor da função executada sem encapsular o mesmo em um functor, então na última chamada da pilha de maps ao invés de chamar <code class=\"language-text\">map(anyValue).value</code> você vai chamar apenas <code class=\"language-text\">flatMap(anyValue)</code></li>\n</ul>\n<p>agora com o nosso functor helper, podemos converter a função convertMoneyToNumber para:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertMoneyToNumber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">money</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">functor</span><span class=\"token punctuation\">(</span>money<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">money</span> <span class=\"token operator\">=></span> money<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\$/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>parseFloat<span class=\"token punctuation\">)</span> <span class=\"token comment\">//same as .map(money => parseFloat(money))</span>\n    <span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>agora nós podemos mapear qualquer tipo de valor transformando seu valor original em um novo valor, não apenas arrays! E só para deixarmos claro essa é só a base da ideia de functors, temos muitas outras variantes.</p>\n<p>Eu espero que você tenha aprendido algo novo hoje! </p>","fields":{"slug":"/pt-br/o-jeito-mais-simples-de-entender-functors/"},"frontmatter":{"title":"O jeito mais fácil de entender functors","date":"July 14, 2020","description":"O jeito mais fácil de entender functors na minha humilde opinião é o conceito...","languageKey":"en","languageLink":"pt-br/o-jeito-mais-simples-de-entender-functors"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/pt-br/o-jeito-mais-simples-de-entender-functors/","previous":{"fields":{"slug":"/en/the-easier-way-to-understand-functors/"},"frontmatter":{"title":"The easier way to understand functors"}},"next":null}}}
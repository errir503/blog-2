{"componentChunkName":"component---src-templates-blog-post-js","path":"/pt-br/dominando-code-splitting-com-webpack/","result":{"data":{"site":{"siteMetadata":{"title":"Diel Duarte blog","author":"Diel Duarte","siteUrl":"https://dielduarte.dev","pt_br":{"rootPath":"/blog/pt-br","title":"Bem vindo ao meu blog!"},"en":{"rootPath":"/blog/","title":"Welcome to my blog!"}}},"markdownRemark":{"id":"95a96cd1-5e69-52ee-b6d3-e3c1db3fb11b","excerpt":"Code Splitting √© um processo em build time que quebra parte do seu c√≥digo em pequenos peda√ßos que s√£o requisitados de forma ass√≠ncrona, apenas quando necess√°rio‚Ä¶","html":"<p>Code Splitting √© um processo em build time que quebra parte do seu c√≥digo em pequenos peda√ßos que s√£o requisitados de forma ass√≠ncrona, apenas quando necess√°rio. Vamos conversar sobre como Webpack pode ajudar no processo de Code Splitting para atingir a meta de um site mais perform√°tico.</p>\n<h2 class=\"subtitle--separator\">Mas primeiro, como saber quando eu tenho que quebrar o meu c√≥digo em pequenos peda√ßos (chunks)?</h2>\n<p>Os processos mais caros quando falamos sobre renderizar um Website s√£o os processos de download e parsing do Javascript e CSS. Sabendo desse fato, se n√≥s n√£o precisamos de uma parte espec√≠fica do c√≥digo no primeiro render, esse c√≥digo √© um √≥timo candidato para ser quebrado em uma outra parte e ser baixado sobre demanda. </p>\n<p>O Google Chrome tem uma √≥tima ferramenta chamada <code class=\"language-text\">coverage</code> que nos mostra qual porcentagem do c√≥digo baixado est√° ou n√£o est√° sendo usado. Isso pode ser usado como uma m√©trica para seguir e saber o quanto do c√≥digo baixado poderia ser quebrado em partes ass√≠ncronas.</p>\n<p>Para usar essa ferramenta abra o dev tools do Chrome, <code class=\"language-text\">cmd/ctrl + p</code>, e digite <code class=\"language-text\">show coverage</code>:</p>\n<p><img src=\"/blog/images/coverage.png\" alt=\"imagem mostrando como acessar a janela coverage no dev tools do Chrome\"> </p>\n<p>Uma vez que abrimos a op√ß√£o coverage, clique no bot√£o de reload e espere at√© que nosso site seja completamente carregado. Os resultados v√£o nos motrar o quanto do c√≥digo carregado por arquivo est√° sendo usado. √â maravilhoso! üòç</p>\n<p><img src=\"/blog/images/result.png\" alt=\"imagem mostrando a tab coverage, onde nos podemos ver a lista de arquivos baixados e o quanto do c√≥digo de cada arquivo est√° sendo usado.\"> </p>\n<p>No exemplo abaixo, 46% do c√≥digo entregue <code class=\"language-text\">n√£o</code> est√° sendo usado, essa m√©trica tamb√©m √© relativa, dependende do tamanho do arquivo e de muitas outras vari√°veis. Ent√£o √© sempre bom entender o contexto que estamos trabalhando quando estivermos usando essas ferramentas.</p>\n<h2>Code splitting e webpack</h2>\n<p>Com Webpack nos temos duas formas de trabalhar com Code Splitting, imports est√°ticos e din√¢micos. As duas formas usam <a href=\"https://v8.dev/features/dynamic-import\">dynamic imports, uma feature do es2020</a></p>\n<h3>Imports est√°ticos</h3>\n<ul>\n<li>√â bom para ser usado quanto estivermos importando bibliotecas/m√≥dulos de Javascript pesados.</li>\n<li>Qualquer parte do c√≥digo que chamamos de temporal, ou seja, coisas que n√£o s√£o v√≠siveis todo o tempo na sua p√°gina, exemplos: tooltips, modais/alertas.</li>\n<li>Rotas.</li>\n</ul>\n<p>Para usar imports est√°ticos no seu c√≥digo, √© muito simples: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path/to/myModule.js'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">module</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Ou ainda melhor, criando uma fun√ß√£o que importa o m√≥dulo quando necess√°rio. O import do arquivo √© feito apenas uma vez, depois da primeira √© cacheado e na pr√≥xima vez que usar a fun√ß√£o o m√≥dulo √© retornado instantaneamente, exemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> getModule <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> ‚áí <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path/to/myModule.js'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">getModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">module</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Imports Dinamicos</h3>\n<p>Imports din√¢micos n√£o s√£o de verdade din√¢micos, porque eles acontecem em build time. Ao usar imports din√¢micos estamos dizendo para o Webpack: Ei Webpack, por favor, crie todos os chunks poss√≠veis para o caminho que eu estou te passando, seja uma pasta, ou v√°rias em build time. Dessa forma nos conseguimos usar vari√°veis o que torna esse processo de import ‚Äúdin√¢mico‚Äù.</p>\n<p>Vamos considerar que n√≥s temos uma pasta de temas, ex:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">themes\n  ‚îî‚îÄ‚îÄ dark<span class=\"token punctuation\">.</span>js\n  ‚îî‚îÄ‚îÄ light<span class=\"token punctuation\">.</span>js</code></pre></div>\n<p>Como exemplo n√≥s poderiamos importar os temas assim:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> getTheme <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>theme<span class=\"token punctuation\">)</span> ‚áí <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">path/to/themes/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>theme<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">getTheme</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dark'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">theme</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Dessa forma o Webpack vai criar todos os poss√≠veis chunks em build time para cada tema dentro da pasta <code class=\"language-text\">themes</code>, essa t√©cnica √© chamada de <code class=\"language-text\">ContextModule</code> dentro do c√≥digo do Webpack.</p>\n<h2>Coment√°rios M√°gicos</h2>\n<h3>webpackChunkName</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* webpackChunkName: \"my-chunk-name\" */</span> <span class=\"token string\">'path/to/myModule.js'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Por default o Webpack cria os nomes dos chunks seguindo uma ordem num√©rica, 1.js, 2.js, 3.js, o que torna o processo de reconhecer quais arquivos foram importados dif√≠cil. Usando <code class=\"language-text\">webpackChunkName</code> n√≥s podemos renomear o chunk, √© importante lembrar que para esse coment√°rio m√°gico funcionar n√≥s devemos estar usando <code class=\"language-text\">output.chunkFileName: [name].whateverDoYouWantHere.js</code> no arquivo de configura√ß√£o do Webpack.</p>\n<p>Isso √© √∫til apenas no modo de desenvolvimento, ent√£o podemos fazer algo do tipo ao importar o arquivo:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'development'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* webpackChunkName: \"my-chunk-name\" */</span> <span class=\"token string\">'path/to/myModule.js'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path/to/myModule.js'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>O <code class=\"language-text\">if</code> vai ser removido se o build estiver sendo rodado em modo de produ√ß√£o, e o <code class=\"language-text\">else</code> se estiver rodando em modo de desenvolvimento. Isso √© conhecido como <code class=\"language-text\">dead-code elimination</code> ou em pt-br elimina√ß√£o do c√≥digo morto, ferramentas como Uglify.js e outras usam isso para reduzir o tamanho do arquivo final.</p>\n<h3>webpackMode</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* webpackMode: \"lazy\" */</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">path/to/themes/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>theme<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>O coment√°rio m√°gico <code class=\"language-text\">webpackMode</code> pode receber 4 tipos de valores:</p>\n<ul>\n<li>lazy: gera um chunk para cada arquivo importado dinamicamente, melhor op√ß√£o para ser usado em produ√ß√£o.</li>\n<li>lazy-once: gera um chunk apenas que pode satisfazer a condi√ß√£o do import din√¢mico, melhor op√ß√£o para o modo de desenvolvimento reduzindo o tempo de de gerar os arquivos finais do Webpack.</li>\n<li>eager: n√£o gera nenhum chunk extra, todos os m√≥dulos s√£o gerados em apenas um arquivo e nenhum request extra √© feito.</li>\n<li>weak: √∫til para universal rendering / ou server side rendering, onde os arquivos s√£o servidos manualmente no primeiro render. O que acontece √© que ao requisitar um m√≥dulo uma promisse √© sempre retornada, mas essa promisse s√≥ retorna com sucesso se requisitada pelo client side. Um novo request nunca √© feito, pois os arquivos j√° est√£o no client pois foram servidos pelo servidor.</li>\n</ul>\n<h3>Prefetch e Preload</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* webpackPrefetch: true */</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">path/to/themes/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>theme<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* webpackLoad: true */</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">path/to/themes/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>theme<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Os dois coment√°rios m√°gicos, ir√£o criar uma tag link com <code class=\"language-text\">rel=prefetch</code> ou <code class=\"language-text\">rel=preload</code> automaticamente para voc√™ fazer o prefetching ou preloading dos seus chunks dependendo da implementa√ß√£o. Se voc√™ n√£o sabe o que prefetch e preload links fazem, eu recomendo\na leitura do post <a href=\"https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf\">Preload, Prefetch And Priorities in Chrome</a>.</p>\n<p>Essas foram minhas anota√ß√µes do curso <a href=\"https://frontendmasters.com/courses/performance-webpack/\">Web performance with webpack</a>. Espero que voc√™ tenha aprendido alguma coisa nova hoje, te vejo no pr√≥ximo post! ‚ù§Ô∏è</p>","fields":{"slug":"/pt-br/dominando-code-splitting-com-webpack/"},"frontmatter":{"title":"Dominando code splitting com webpack","date":"July 17, 2019","description":"Vamos conversar sobre como Webpack pode ajudar no processo de code splitting para atingir a meta de um site mais perform√°tico.","languageKey":"pt_br","languageLink":"/en/mastering-code-splitting-with-webpack"}}},"pageContext":{"slug":"/pt-br/dominando-code-splitting-com-webpack/","previous":null,"next":{"fields":{"slug":"/en/mastering-code-splitting-with-webpack/"},"frontmatter":{"title":"Mastering code splitting with webpack"}}}},"staticQueryHashes":["63159454"]}